/*
   DDS 2.7.0   A bridge double dummy solver.
   Copyright (C) 2006-2014 by Bo Haglund
   Cleanups and porting to Linux and MacOSX (C) 2006 by Alex Martelli.
   The code for calculation of par score / contracts is based upon the
   perl code written by Matthew Kidd for ACBLmerge. He has kindly given 
   me permission to include a C++ adaptation in DDS. 

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or 
   implied.  See the License for the specific language governing 
   permissions and limitations under the License.

   This object, TransTable, was was written by Søren Hein. 
   Many thanks for allowing me to include it in DDS. 
*/

/*
   This object arose out of Bo's implementation, but the
   algorithm and data structures are completely different.
   In the process of writing it, I found it necessary to
   encapsulate the code that is specific to transposition
   tables.  One side effect of this may be that others will
   want to try to improve on my work.  I hope so!

   The data structures in this object are heavily optimized.
   Some explanation is included in the code.

   Søren Hein, 2014-09-09.
*/

#include "dds.h"
#include "TransTable.h"

extern unsigned char cardRank[16];
extern char relRank[8192][15];

const char  * players[DDS_HANDS] = {
  "North", "East", "South", "West" 
};
 


/* 
   There are some constants that only need to be calculated
   once.  In fact they are the same for all instances of the
   object.  In order to save time and memory, they share a
   single memory.

   Each 13-bit number, aggr, represents a possible set of cards
   remaining in a suit.  For example, 0x15a2 represents
   A(1) QT(5) 97(a) 3(2). 

   lowestRank[aggr] gives the lowest rank that is in play in
   aggr.  The ace is 14, the deuce is 2.  A void counts as
   rank 15 ("not even the ace").  It would go horribly wrong
   if this rank were chosen to be 0, as might seem intuitive.

   maskBytes[aggr][suit] is a set of 4 32-bit integers, 
   where suit is 0 ..3 (spades .. clubs).  Each integer only
   has 8 of its 32 bits set, but these 8 bits could be either
   in the top byte (byte 0) or any of the others (bytes 1 ..3).
   The bytes are abbreviated as B0 .. B3 below.

                     int 0       int 1       int 2       int 3
   suit 0, spades    B0 R0       B0 R1       B0 R2       B0 R3
   suit 1, hearts    B1 R0       B1 R1       B1 R2       B1 R3
   suit 2, diamonds  B2 R0       B2 R1       B2 R2       B2
   suit 3, clubs     B3 R0       B3 R1       B3 R2       B3

   R0 .. R3 are explained now.  The purpose of maskBytes is
   to generate 32-bit masks for later use with actual suits.
   As a card can be with either of 4 players, 2 bits are needed
   to encode the position of a card.  Therefore the masks also
   need 2 bits per card, even though the 2 bits are identical.

   In the table, R0 means the top byte (8 bits = 4 cards) of
   a holding.

   R0 AKQJ
   R1 T987
   R2 6543
   R3 2

   For example, if the ace is held by North, the king by South, the
   queen and jack by West, then the top byte for that SUIT would be

   00(North) 10(South) 11(West) 11(West)

   The MASK for that holding would be 11 11 11 11, as all four
   cards are in play.

   If the jack were missing, because it had already been played,
   then the suit would be 00 10 11 00 (a missing card is also
   encoded as 00), and the mask would be 11 11 11 00.

   Later on, when we have a specific set of spades .. clubs,
   we want to check whether those cards are already in the
   transposition table.  As far as the necessary masks is
   concerned, this is generated by an OR (|) of the four 
   32-bit integers in a column of the table above.  
   
   So the first column yields four bytes which are already 
   shifted in place, all corresponding to R0.  The mask 
   corresponds to the AKQJ of the four suits in order.

   It's not really AKQJ, but the four highest cards still in
   play in that suit.  So missing cards are always at the end
   of the list.
*/

bool			_constantsSet = false;
int			maskBytes[8192][DDS_SUITS][TT_BYTES];
int			lowestRank[8192];


TransTable::TransTable()
{
  if (! _constantsSet)
  {
    _constantsSet = true;
    TransTable::SetConstants();
  }

  poolp        = NULL;
  pagesDefault = NUM_PAGES_DEFAULT;
  pagesMaximum = NUM_PAGES_MAXIMUM;
  pagesCurrent = 0;

  memState     = FROM_POOL;
  harvestTrick = FIRST_HARVEST_TRICK;
  harvestHand  = 0;

  harvested.nextBlockNo = 0;

  timestamp    = 0;

  pageStats.numResets   = 0;
  pageStats.numCallocs  = 0;
  pageStats.numFrees    = 0;
  pageStats.numHarvests = 0;
  pageStats.lastCurrent = 0;

  TTInUse = 0;

  sprintf(fname, "");
  fp = stdout;
}


TransTable::~TransTable()
{
  TransTable::ReturnAllMemory();

  if (fp != stdout)
    fclose(fp);
}


void TransTable::SetConstants()
{
  int winMask[8192];

  unsigned int topBitRank = 1;
  winMask[0]    =  0;
  lowestRank[0] = 15;  // Void

  for (int ind = 1; ind < 8192; ind++)
  {
    if (ind >= (topBitRank + topBitRank)) /* Next top bit */
      topBitRank <<= 1;

    strncpy(relRank[ind], relRank[ind ^ topBitRank], 15);

    // winMask is a growing list of 11's.  In the end it will
    // have 26 bits, so 13 groups of two bits.  It always 
    // consists of all 11's, then all 00's.

    winMask[ind] = (winMask[ind ^ topBitRank] >> 2) | (3 << 24);

    maskBytes[ind][0][0] = (winMask[ind] <<  6) & 0xff000000;
    maskBytes[ind][0][1] = (winMask[ind] << 14) & 0xff000000;
    maskBytes[ind][0][2] = (winMask[ind] << 22) & 0xff000000;
    maskBytes[ind][0][3] = (winMask[ind] << 30) & 0xff000000;

    maskBytes[ind][1][0] = (winMask[ind] >>  2) & 0x00ff0000;
    maskBytes[ind][1][1] = (winMask[ind] <<  6) & 0x00ff0000;
    maskBytes[ind][1][2] = (winMask[ind] << 14) & 0x00ff0000;
    maskBytes[ind][1][3] = (winMask[ind] << 22) & 0x00ff0000;

    maskBytes[ind][2][0] = (winMask[ind] >> 10) & 0x0000ff00;
    maskBytes[ind][2][1] = (winMask[ind] >>  2) & 0x0000ff00;
    maskBytes[ind][2][2] = (winMask[ind] <<  6) & 0x0000ff00;
    maskBytes[ind][2][3] = (winMask[ind] << 14) & 0x0000ff00;

    maskBytes[ind][3][0] = (winMask[ind] >> 18) & 0x000000ff;
    maskBytes[ind][3][1] = (winMask[ind] >> 10) & 0x000000ff;
    maskBytes[ind][3][2] = (winMask[ind] >>  2) & 0x000000ff;
    maskBytes[ind][3][3] = (winMask[ind] <<  6) & 0x000000ff;

    lowestRank[ind] = lowestRank[ind ^ topBitRank] - 1;
  }
}


void TransTable::Init(int handLookup[][15])
{
  // This is very similar to SetConstants, except that it
  // happens with actual cards.  It also makes sense to
  // keep a record of aggrRanks for each suit.  These are
  // only used later for xorSet.

  unsigned int		topBitRank = 1;
  unsigned int		topBitNo   = 2;
  aggrType 		* ap;

  for (int s = 0; s < DDS_SUITS; s++)
    aggr[0].aggrRanks[s] = 0;

  for (int ind = 1; ind < 8192; ind++)
  {
    if (ind >= (topBitRank << 1))
    {
      /* Next top bit */
      topBitRank <<= 1;
      topBitNo++;
    }

    aggr[ind] = aggr[ind ^ topBitRank];
    ap = &aggr[ind];

    for (int s = 0; s < DDS_SUITS; s++)
    {
      ap->aggrRanks[s]  = (ap->aggrRanks[s] >> 2) | 
                          (handLookup[s][topBitNo] << 24);
    }

    ap->aggrBytes[0][0] = (ap->aggrRanks[0] <<  6) & 0xff000000;
    ap->aggrBytes[0][1] = (ap->aggrRanks[0] << 14) & 0xff000000;
    ap->aggrBytes[0][2] = (ap->aggrRanks[0] << 22) & 0xff000000;
    ap->aggrBytes[0][3] = (ap->aggrRanks[0] << 30) & 0xff000000;

    ap->aggrBytes[1][0] = (ap->aggrRanks[1] >>  2) & 0x00ff0000;
    ap->aggrBytes[1][1] = (ap->aggrRanks[1] <<  6) & 0x00ff0000;
    ap->aggrBytes[1][2] = (ap->aggrRanks[1] << 14) & 0x00ff0000;
    ap->aggrBytes[1][3] = (ap->aggrRanks[1] << 22) & 0x00ff0000;

    ap->aggrBytes[2][0] = (ap->aggrRanks[2] >> 10) & 0x0000ff00;
    ap->aggrBytes[2][1] = (ap->aggrRanks[2] >>  2) & 0x0000ff00;
    ap->aggrBytes[2][2] = (ap->aggrRanks[2] <<  6) & 0x0000ff00;
    ap->aggrBytes[2][3] = (ap->aggrRanks[2] << 14) & 0x0000ff00;

    ap->aggrBytes[3][0] = (ap->aggrRanks[3] >> 18) & 0x000000ff;
    ap->aggrBytes[3][1] = (ap->aggrRanks[3] >> 10) & 0x000000ff;
    ap->aggrBytes[3][2] = (ap->aggrRanks[3] >>  2) & 0x000000ff;
    ap->aggrBytes[3][3] = (ap->aggrRanks[3] <<  6) & 0x000000ff;
  }
}


void TransTable::SetMemoryDefault(int megabytes)
{
  double blockMem = BLOCKS_PER_PAGE * sizeof(winBlockType) /
    (double) 1024.;

  int pagesDefault = (int) (1024 * megabytes) / blockMem;
}


void TransTable::SetMemoryMaximum(int megabytes)
{
  double blockMem = BLOCKS_PER_PAGE * sizeof(winBlockType) /
    (double) 1024.;

  int pagesMaximum = (int) (1024 * megabytes) / blockMem;
}


void TransTable::MakeTT()
{
  if (! TTInUse)
  {
    TTInUse = 1;

    for (int t = 0; t < TT_TRICKS; t++)
    {
      for (int h = 0; h < DDS_HANDS; h++)
      {
        TTroot[t][h] = (distHashType *)
          malloc(256 * sizeof(distHashType));
      
        if (TTroot[t][h] == NULL)
          exit(1);
      }
    }
  }

  TransTable::InitTT();
}


void TransTable::InitTT()
{
  for (int c = 0; c < TT_TRICKS; c++)
  {
    for (int h = 0; h < DDS_HANDS; h++)
    {
      for (int i = 0; i < 256; i++)
      {
        TTroot[c][h][i].nextNo      = 0;
        TTroot[c][h][i].nextWriteNo = 0;

      }
      lastBlockSeen[c][h] = NULL;
    }
  }
}


void TransTable::ReleaseTT()
{
  if (! TTInUse)
    return;
  TTInUse = 0;

  for (int t = 0; t < TT_TRICKS; t++)
  {
    for (int h = 0; h < DDS_HANDS; h++)
    {
      if (TTroot[t][h] == NULL)
        continue;
      
      free(TTroot[t][h]);
    }
  }
}


void TransTable::ResetMemory()
{
  if (poolp == NULL)
    return;

  pageStats.numResets++;
  pageStats.numCallocs  += pagesCurrent - pageStats.lastCurrent;
  pageStats.lastCurrent  = pagesCurrent;

  while (pagesCurrent > pagesDefault)
  {
    free(poolp->list);
    poolp = poolp->prev;

    free(poolp->next);
    poolp->next = NULL;

    pagesCurrent--;
  }

  pageStats.numFrees += pageStats.lastCurrent - pagesCurrent;
  pageStats.lastCurrent = pagesCurrent;

  while (poolp->prev)
    poolp = poolp->prev;

  poolp->nextBlockNo = 0;
  nextBlockp = poolp->list;

  TransTable::InitTT();

  timestamp = 0;

  memState  = FROM_POOL;

  return;
}


void TransTable::ReturnAllMemory()
{
  poolType * tmp; 

  while (poolp)
  {
    free(poolp->list);
    tmp = poolp;
    poolp = poolp->prev;
    free(tmp);
  }
  pagesCurrent = 0;

  pageStats.numResets   = 0;
  pageStats.numCallocs  = 0;
  pageStats.numFrees    = 0;
  pageStats.numHarvests = 0;
  pageStats.lastCurrent = 0;

  TransTable::ReleaseTT();

  return;
}


int TransTable::BlocksInUse()
{
  poolType * pp = poolp;
  int count = 0;

  do
  {
    count += pp->nextBlockNo;
    pp = pp->prev;
  }
  while (pp);

  return count;
}


double TransTable::MemoryInUse()
{
  int blockMem = BLOCKS_PER_PAGE * pagesCurrent * sizeof(winBlockType);
  int aggrMem  = 8192 * sizeof(aggrType);
  int rootMem  = TT_TRICKS * DDS_HANDS * 256 * sizeof(distHashType);

  return (blockMem + aggrMem + rootMem) / (double) 1024.;
}


winBlockType * TransTable::GetNextCardBlock()
{
  /*
     Spaghetti code.  The basic idea is that there is a pool of
     pages.  When a page runs out, we get a next pool.  But we're
     only allowed a certain maximum number, and calloc might also
     fail before then.  We have a default number of pages that
     we don't give back voluntarily once we have acquired them,
     but we give back anything more than that at the end of each
     hand.  If this overall mechanism fails, then we try to harvest
     old entries scattered throughout the TT memory.  If we get
     enough for a "page", then we use that single page, and if
     that runs out later, we try to harvest some more, starting 
     where we left off harvesting last time.  If the harvesting also
     fails, then we reset whatever TT memory we do have, and we
     continue with that.
  */

  if (poolp == NULL)
  {
    // Have to be able to get at least one pool.
    poolp = (poolType *) calloc(1, sizeof(poolType));
    if (poolp == NULL)
      exit(1);

    poolp->list = (winBlockType *)
      malloc(BLOCKS_PER_PAGE * sizeof(winBlockType));

    if (! poolp->list)
      exit(1);

    poolp->next        = NULL;
    poolp->prev        = NULL;
    poolp->nextBlockNo = 1;

    nextBlockp    = poolp->list;

    pagesCurrent++;

    return nextBlockp++;
  }
  else if (memState == FROM_HARVEST)
  {
    // Not allowed to get more memory, so reuse old one.
    int n = harvested.nextBlockNo;
    if (n == BLOCKS_PER_PAGE)
    {
      if (! TransTable::Harvest())
      {
        TransTable::ResetMemory();
	poolp->nextBlockNo++;
	return nextBlockp++;
      }
      n = 0;
    }

    harvested.nextBlockNo++;
    return harvested.list[n];
  }
  else if (poolp->nextBlockNo == BLOCKS_PER_PAGE)
  {
    if (poolp->next)
    {
      // Reuse a dormant block that has not been freed.
      poolp              = poolp->next;
      poolp->nextBlockNo = 1;
      nextBlockp         = poolp->list;

      return nextBlockp++;
    }
    else if (pagesCurrent == pagesMaximum)
    {
      // Have to try to reclaim memory.
      if (! TransTable::Harvest())
      {
        TransTable::ResetMemory();
	poolp->nextBlockNo++;
	return nextBlockp++;
      }

      memState = FROM_HARVEST;
      harvested.nextBlockNo++;
      return harvested.list[0];
    }
    else
    {
      // Make a new pool.
      poolType * newpoolp = (poolType *) calloc(1, sizeof(poolType));

      if (newpoolp == NULL)
      {
        // Unexpected, but try harvesting before we give up
	// and start over.
        if (! TransTable::Harvest())
        {
          TransTable::ResetMemory();
	  poolp->nextBlockNo++;
	  return nextBlockp++;
        }

        memState = FROM_HARVEST;
        harvested.nextBlockNo++;
        return harvested.list[0];
      }

      newpoolp->list = (winBlockType *)
        malloc(BLOCKS_PER_PAGE * sizeof(winBlockType));
    
      if (! newpoolp->list)
      {
        if (! TransTable::Harvest())
        {
          TransTable::ResetMemory();
	  poolp->nextBlockNo++;
	  return nextBlockp++;
        }

        memState = FROM_HARVEST;
        harvested.nextBlockNo++;
        return harvested.list[0];
      }

      newpoolp->nextBlockNo = 1;
      newpoolp->next        = NULL;
      newpoolp->prev        = poolp;

      poolp->next = newpoolp;
      poolp       = newpoolp;

      nextBlockp  = newpoolp->list;

      pagesCurrent++;

      return nextBlockp++;
    }
  }

  poolp->nextBlockNo++;
  return nextBlockp++;
}


bool TransTable::Harvest()
{
  distHashType * rootptr = TTroot[harvestTrick][harvestHand];
  distHashType * ptr;
  winBlockType * bp;

  int trick = harvestTrick;
  int hand  = harvestHand;
  int hash, suit, hno = 0;

  while (1)
  {
    for (hash = 0; hash < 256; hash++)
    {
      ptr = &rootptr[hash];
      for (suit = ptr->nextNo-1; suit >= 0; suit--)
      {
        bp = ptr->list[suit].posBlock;
	if (timestamp - bp->timestampRead > HARVEST_AGE)
	{
	  bp->nextMatchNo     = 0;
	  bp->nextWriteNo     = 0;
	  bp->timestampRead   = timestamp;
	  harvested.list[hno] = bp;

          // Swap the last element down.
	  if (suit != ptr->nextNo-1)
	    ptr->list[suit] = ptr->list[ ptr->nextNo-1 ];

          ptr->nextNo--;
	  ptr->nextWriteNo = ptr->nextNo;

	  if (++hno == BLOCKS_PER_PAGE)
	  {
	    if (++harvestHand >= DDS_HANDS)
	    {
	      // Skip rest of this [trick][hand] for simplicity.
	      harvestHand = 0;
	      if (--harvestTrick < 0)
	        harvestTrick = FIRST_HARVEST_TRICK;
	    }

	    harvested.nextBlockNo = 0;
	    pageStats.numHarvests++;
	    return true;
	  }
	}
      }
    }

    if (++harvestHand >= DDS_HANDS)
    {
      harvestHand = 0;
      if (--harvestTrick < 0)
        harvestTrick = FIRST_HARVEST_TRICK;
    }

    if (harvestTrick == trick && harvestHand == hand)
      return false;
    
    rootptr = TTroot[harvestTrick][harvestHand];
  }
}


int TransTable::hash8(int * handDist)
{
  /*
     handDist is an array of hand distributions, North .. West.
     Each entry is a 12-bit number with 3 groups of 4 bits.
     Each group is the binary representation of the number of
     cards held in that suit.  The suits are in order spades,
     hearts, diamonds.  Clubs can be neglected, as the total
     number of cards in a hand is given by the trick number.

     For example, if handDist[1] equals 0x0433, then East holds
     4 spades, 3 hearts, 3 diamonds and the rest in clubs.
     If this is after the second trick, there are 11 cards, so
     East must hold 1 club.

     The hash function turns all 4 hand distributions into a
     single 8-bit number.  The numbers should be spread as
     evenly as possible across the 256 possibilities.  I've not
     done extensive research into finding the best hash function,
     but this one seems OK.  It uses a small prime, 5, and its
     powers.  The shift at the end is in order to get some use
     out of the bits above the first 8 ones.
  */

  int h =
   (handDist[0] ^
  ((handDist[1] *    5)     ) ^
  ((handDist[2] *   25)     ) ^
  ((handDist[3] *  125)     ) );

  return (h ^ (h >> 5)) & 0xff;
}


nodeCardsType * TransTable::Lookup(
  int			tricks,
  int			hand,
  unsigned short 	aggrTarget[],
  int			handDist[],
  int			limit,
  bool			* lowerFlag)
{
  // First look up distribution.
  long long suitLengths = 
    (((long long) handDist[0]) << 36) |
    (((long long) handDist[1]) << 24) |
    (((long long) handDist[2]) << 12) |
    (((long long) handDist[3])      );

  int hashkey = hash8(handDist);

  bool empty;
  lastBlockSeen[tricks][hand] =
    LookupSuit(&TTroot[tricks][hand][hashkey], 
      suitLengths, &empty);
  if (empty)
    return NULL;

  // If that worked, look up cards.
  int * ab0 = aggr[ aggrTarget[0] ].aggrBytes[0];
  int * ab1 = aggr[ aggrTarget[1] ].aggrBytes[1];
  int * ab2 = aggr[ aggrTarget[2] ].aggrBytes[2];
  int * ab3 = aggr[ aggrTarget[3] ].aggrBytes[3];

  winMatchType TTentry;
  TTentry.topSet1 = ab0[0] | ab1[0] | ab2[0] | ab3[0];
  TTentry.topSet2 = ab0[1] | ab1[1] | ab2[1] | ab3[1];
  TTentry.topSet3 = ab0[2] | ab1[2] | ab2[2] | ab3[2];
  TTentry.topSet4 = ab0[3] | ab1[3] | ab2[3] | ab3[3];

  return TransTable::LookupCards(&TTentry, 
    lastBlockSeen[tricks][hand], limit, lowerFlag);
}


winBlockType * TransTable::LookupSuit(
  distHashType		* dp,
  long long 		key,
  bool			* empty)
{
  /*
     Always returns a valid winBlockType.
     If empty == true, there was no match, so there is
     no point in looking for a card match.
     If empty == false, there were entries already.
  */
  
  int n = dp->nextNo;
  for (int i = 0; i < n; i++)
  {
    if (dp->list[i].key == key)
    {
      *empty = false;
      return dp->list[i].posBlock;
    }
  }

  *empty = true;
  int m;

  if (n == DISTS_PER_ENTRY)
  {
    // No room for new exact suits at this hash position.
    // Have to reuse an existing posBlock.
    if (dp->nextWriteNo == DISTS_PER_ENTRY)
    {
      m = 0;
      dp->nextWriteNo = 1;
    }
    else
      m = dp->nextWriteNo++;
  }
  else
  {
    // Didn't find an exact match, but there is still room.
    // The following looks a bit odd because it is possible that
    // GetNextCardBlock wipes out the whole memory, so we
    // have to use the up-to-date location, not m from above.

    winBlockType * bp = GetNextCardBlock();
    m = dp->nextWriteNo++;
    dp->list[m].posBlock = bp;
    dp->list[m].posBlock->timestampRead = timestamp;
    dp->nextNo++;
  }

  // As long as the secondary Lookup loop in ABsearch exists,
  // it will cause spurious extra blocks to be created here
  // which are not useful, because nothing is ever Add'ed.
  // This is not a memory leak, as the memory is properly freed,
  // but it is also a small waste of about 0.5%.  I don't mind.

  dp->list[m].key      = key;
  dp->list[m].posBlock->nextMatchNo   = 0;
  dp->list[m].posBlock->nextWriteNo   = 0;

  return dp->list[m].posBlock;
}


nodeCardsType * TransTable::LookupCards(
  winMatchType		* searchp,
  winBlockType		* bp,
  int			limit,
  bool			* lowerFlag)
{
  winMatchType * wp;

  int n = bp->nextWriteNo - 1;
  wp = &bp->list[n];

  // It may be a bit silly to duplicate the code like this.
  // It could be combined to one loop with a slight overhead.

  for (int i = n; i >= 0; i--, wp--)
  {
    if ((wp->topSet1 ^ searchp->topSet1) & wp->topMask1) 
      continue;

    if (wp->lastMaskNo != 1)
    {
      if ((wp->topSet2 ^ searchp->topSet2) & wp->topMask2) 
        continue;

      if (wp->lastMaskNo != 2)
      {
        if ((wp->topSet3 ^ searchp->topSet3) & wp->topMask3) 
          continue;
      }
    }

    // Check bounds.
    nodeCardsType * nodep = &wp->first;
    if (nodep->lbound > limit)
    {
      bp->timestampRead = ++timestamp;
      * lowerFlag = true;
      return nodep;
    }
    else if (nodep->ubound <= limit)
    {
      bp->timestampRead = ++timestamp;
      * lowerFlag = false;
      return nodep;
    }
  }

  int n2 = bp->nextMatchNo-1;
  wp = &bp->list[n2];

  for (int i = n2; i > n; i--, wp--)
  {
    if ((wp->topSet1 ^ searchp->topSet1) & wp->topMask1) 
      continue;

    if (wp->lastMaskNo != 1)
    {
      if ((wp->topSet2 ^ searchp->topSet2) & wp->topMask2) 
        continue;

      if (wp->lastMaskNo != 2)
      {
        if ((wp->topSet3 ^ searchp->topSet3) & wp->topMask3) 
          continue;
      }
    }

    nodeCardsType * nodep = &wp->first;
    if (nodep->lbound > limit)
    {
      * lowerFlag = true;
      bp->timestampRead = ++timestamp;
      return nodep;
    }
    else if (nodep->ubound <= limit)
    {
      * lowerFlag = false;
      bp->timestampRead = ++timestamp;
      return nodep;
    }
  }

  return NULL;
}


void TransTable::CreateOrUpdate(
  winBlockType		* bp,
  winMatchType		* searchp,
  bool 			flag)
{
  // Either updates an existing SOP or creates a new one.
  // A new one is created at the end of the bp list if this
  // is not already full, or the oldest one in the list is
  // overwritten.

  winMatchType * wp = bp->list;
  int n = bp->nextMatchNo;

  for (int i = 0; i < n; i++, wp++)
  {
    if (wp->xorSet    != searchp->xorSet   ) continue;
    if (wp->maskIndex != searchp->maskIndex) continue;
    if (wp->topSet1   != searchp->topSet1  ) continue;
    if (wp->topSet2   != searchp->topSet2  ) continue;
    if (wp->topSet3   != searchp->topSet3  ) continue;

    nodeCardsType * nodep = &wp->first;
    if (searchp->first.lbound > nodep->lbound)
      nodep->lbound = searchp->first.lbound;
    if (searchp->first.ubound < nodep->ubound)
      nodep->ubound = searchp->first.ubound;

    nodep->bestMoveSuit = searchp->first.bestMoveSuit;
    nodep->bestMoveRank = searchp->first.bestMoveRank;
    return;
  }

  if (n == BLOCKS_PER_ENTRY)
  {
    if (bp->nextWriteNo >= BLOCKS_PER_ENTRY)
      bp->nextWriteNo = 0;
  }
  else
    bp->nextMatchNo++;


  wp  = &bp->list[ bp->nextWriteNo++ ];
  *wp = *searchp;

  if (!flag)
  {
    wp->first.bestMoveSuit = 0;
    wp->first.bestMoveRank = 0;
  }
}


void TransTable::Add(
  int			tricks,
  int			hand,
  unsigned short	* aggrTarget,
  unsigned short	* winRanks,
  nodeCardsType		* first,
  bool			flag)
{
  if (lastBlockSeen[tricks][hand] == NULL)
  {
    // We have recently reset the entire memory, and we were
    // in the middle of a recursion.  So we'll just have to
    // drop this entry that we were supposed to be adding.
    return;
  }

  int * ab[DDS_SUITS];
  int * mb[DDS_SUITS];
  char low[DDS_SUITS];
  unsigned short int w, ag;
  winMatchType TTentry;

  // Inefficient, as it also copies leastWin.
  // In fact I'm not quite happy with the treatment of
  // leastWin in general.

  TTentry.first = *first;

  TTentry.xorSet = 0;

  for (int ss = 0; ss < DDS_SUITS; ss++)
  {
    w = winRanks[ss];
    if (w == 0)
    {
      ab[ss]   = aggr[0].aggrBytes[ss];
      mb[ss]   = maskBytes[0][ss];
      low[ss]  = 15;
      TTentry.first.leastWin[ss] = 0;
    }
    else
    {
      w        = w & (-w);     /* Only lowest win */
      ag       = aggrTarget[ss] & (-w);

      ab[ss]   = aggr[ag].aggrBytes[ss];
      mb[ss]   = maskBytes[ag][ss];
      low[ss]  = lowestRank[ag];

      TTentry.first.leastWin[ss] = 15 - low[ss];
      TTentry.xorSet ^= aggr[ag].aggrRanks[ss];
    }
  }

  // It's a bit annoying that we may be regenerating these.
  // But winRanks can cause them to change after lookup().

  TTentry.topSet1  = ab[0][0] | ab[1][0] | ab[2][0] | ab[3][0];
  TTentry.topSet2  = ab[0][1] | ab[1][1] | ab[2][1] | ab[3][1];
  TTentry.topSet3  = ab[0][2] | ab[1][2] | ab[2][2] | ab[3][2];
  TTentry.topSet4  = ab[0][3] | ab[1][3] | ab[2][3] | ab[3][3];

  TTentry.topMask1 = mb[0][0] | mb[1][0] | mb[2][0] | mb[3][0];
  TTentry.topMask2 = mb[0][1] | mb[1][1] | mb[2][1] | mb[3][1];
  TTentry.topMask3 = mb[0][2] | mb[1][2] | mb[2][2] | mb[3][2];
  TTentry.topMask4 = mb[0][3] | mb[1][3] | mb[2][3] | mb[3][3];

  TTentry.maskIndex =
    (low[0] << 12) | (low[1] << 8) | (low[2] << 4) | low[3];

  if (TTentry.topMask2 == 0)
    TTentry.lastMaskNo = 1;
  else if (TTentry.topMask3 == 0)
    TTentry.lastMaskNo = 2;
  else if (TTentry.topMask4 == 0)
    TTentry.lastMaskNo = 3;
  else
    TTentry.lastMaskNo = 4;

  TransTable::CreateOrUpdate(lastBlockSeen[tricks][hand],
    &TTentry, flag);
}



void TransTable::PrintMatch(
  winMatchType 		* wp,
  unsigned char		lengths[DDS_HANDS][DDS_SUITS])
{
  char hands[DDS_HANDS][DDS_SUITS][TT_LINE_LEN];
  int  used[DDS_HANDS][DDS_SUITS];

  for (int h = 0; h < DDS_HANDS; h++)
  {
    for (int s = 0; s < DDS_SUITS; s++)
    {
      used[h][s] = 0;
      for (int c = 0; c < TT_LINE_LEN; c++)
        hands[h][s][c] = 0;
    }
  }

  TransTable::SetToPartialHands(
    wp->topSet1, wp->topMask1, 14, 4, hands, used);
  TransTable::SetToPartialHands(
    wp->topSet2, wp->topMask2, 10, 4, hands, used);
  TransTable::SetToPartialHands(
    wp->topSet3, wp->topMask3,  6, 4, hands, used);
  TransTable::SetToPartialHands(
    wp->topSet4, wp->topMask4,  2, 1, hands, used);

  TransTable::DumpHands(hands, lengths);

  TransTable::PrintNodeValues(&wp->first);
}


void TransTable::PrintNodeValues(
  nodeCardsType		* np)
{
  if (!np)
  {
    fprintf(fp, "np == NULL\n");
    return;
  }

  fprintf(fp, "Lowest used\t%c%c, %c%c, %c%c, %c%c\n",
    cardSuit[0], cardRank[ 15 - (int) np->leastWin[0] ],
    cardSuit[1], cardRank[ 15 - (int) np->leastWin[1] ],
    cardSuit[2], cardRank[ 15 - (int) np->leastWin[2] ],
    cardSuit[3], cardRank[ 15 - (int) np->leastWin[3] ]);

  fprintf(fp, "Bounds\t\t%d to %2d tricks\n",
    (int) np->lbound, (int) np->ubound);

  fprintf(fp, "Best move\t%c%c\n",
    cardSuit[ (int) np->bestMoveSuit ],
    cardRank[ (int) np->bestMoveRank ]);

  fprintf(fp, "\n");
}


void TransTable::MakeHolding(
  char 			* high, 
  int 			len, 
  char 			* res)
{
  int l = strlen(high);
  strcpy(res, high);

  if (len == 0 && (l == 0 || (l == 1 && high[0] == '\0')))
  {
    res[0] = '-';
    res[1] = '\0';
    return;
  }

  for (int i = l; i < len; i++)
  {
    res[i] = 'x';
  }
  res[len] = '\0';
}


void TransTable::DumpHands(
  char 			hands[DDS_HANDS][DDS_SUITS][TT_LINE_LEN], 
  unsigned char 	lengths[DDS_HANDS][DDS_SUITS])
{
  char res_a[TT_LINE_LEN], res_b[TT_LINE_LEN];

  for (int i = 0; i < DDS_SUITS; i++)
  {
    TransTable::MakeHolding(hands[0][i], (int) lengths[0][i], res_a);
    fprintf(fp, "%16s%s\n", "", res_a);
  }

  for (int i = 0; i < DDS_SUITS; i++)
  {
    TransTable::MakeHolding(hands[3][i], (int) lengths[3][i], res_a);
    TransTable::MakeHolding(hands[1][i], (int) lengths[1][i], res_b);
    fprintf(fp, "%-16s%16s%-16s\n", res_a, "", res_b);
  }

  for (int i = 0; i < DDS_SUITS; i++)
  {
    char res[16];
    TransTable::MakeHolding(hands[2][i], (int) lengths[2][i], res);
    fprintf(fp, "%16s%s\n", "", res);
  }
  fprintf(fp, "\n");
}


void TransTable::SetToPartialHands(
  int			set,
  int			mask,
  int			maxRank,
  int			numRanks,
  char 			hands[DDS_HANDS][DDS_SUITS][TT_LINE_LEN],
  int  			used[DDS_HANDS][DDS_SUITS])
{
  for (int s = 0; s < DDS_SUITS; s++)
  {
    for (int rank = maxRank; rank > maxRank - numRanks; rank--)
    {
      int shift = 8*(3-s) + 2*(rank - maxRank + 3);
      int maskCard = mask >> shift;

      if (maskCard & 3)
      {
        int player = (set >> shift) & 3;
	hands[player][s][ used[player][s]++ ] = (char) cardRank[rank];
      }
    }
  }
}


void TransTable::SetFile(char * fname)
{
  if (strlen(fname) > TT_LINE_LEN)
    return;
  
  if (fp != stdout) // Already set
    return;

  strncpy(this->fname, fname, strlen(fname));

  fp = fopen(fname, "w");
  if (! fp)
    fp = stdout;
}


void TransTable::KeyToDist(
  long long		key,
  int			trick,
  int			handDist[])
{
  handDist[0] = (key >> 36) & 0x00000fff;
  handDist[1] = (key >> 24) & 0x00000fff;
  handDist[2] = (key >> 12) & 0x00000fff;
  handDist[3] = (key      ) & 0x00000fff;
}


void TransTable::DistToLengths(
  int			trick,
  int			handDist[],
  unsigned char		lengths[DDS_HANDS][DDS_SUITS])
{
  for (int h = 0; h < DDS_HANDS; h++)
  {
    lengths[h][0] = (handDist[h] >> 8) & 0xf;
    lengths[h][1] = (handDist[h] >> 4) & 0xf;
    lengths[h][2] = (handDist[h]     ) & 0xf;
    lengths[h][3] = trick + 1 
                  - lengths[h][0]
                  - lengths[h][1]
                  - lengths[h][2];
  }
}


void TransTable::LenToStr(
  unsigned char		len[DDS_HANDS][DDS_SUITS],
  char			* line)
{
  sprintf(line,
    "%d=%d=%d=%d \t%d=%d=%d=%d \t%d=%d=%d=%d \t%d=%d=%d=%d",
    len[0][0], len[0][1], len[0][2], len[0][3],
    len[1][0], len[1][1], len[1][2], len[1][3],
    len[2][0], len[2][1], len[2][2], len[2][3],
    len[3][0], len[3][1], len[3][2], len[3][3]);
}
  

void TransTable::PrintSuits(
  int			trick,
  int			hand)
{
  distHashType 		* dp;
  long long		key;
  int			handDist[DDS_HANDS];
  unsigned char		len[DDS_HANDS][DDS_SUITS];
  char			line[40];

  fprintf(fp, "%4s  %2s  %-8s\t%-8s\t%-8s\t%-8s\n",
    "Key",
    "No",
    players[0],
    players[1],
    players[2],
    players[3]);

  for (int hashkey = 0; hashkey < 256; hashkey++)
  {
    dp = &TTroot[trick][hand][hashkey];
    if (dp->nextNo == 0)
      continue;

    for (int i = 0; i < dp->nextNo; i++)
    {
      if (i == 0)
        fprintf(fp, "0x%02x  %2d  ", hashkey, dp->nextNo);
      else
        fprintf(fp, "%4s  %2s  "   , "", "");

      TransTable::KeyToDist(dp->list[i].key, trick, handDist);
      TransTable::DistToLengths(trick, handDist, len);

      TransTable::LenToStr(len, line);
      fprintf(fp, "%s\n", line);
    }
  }
  fprintf(fp, "\n");
}


void TransTable::PrintAllSuits()
{
  for (int trick = 11; trick >= 1; trick--)
  {
    for (int hand = 0; hand < DDS_HANDS; hand++)
    {
      fprintf(fp, "Trick %d, hand %s\n", trick, players[hand]);
      fprintf(fp, "====================\n\n");

      TransTable::PrintSuits(trick, hand);
    }
  }
}


void TransTable::MakeHistStats(
  int			hist[],
  int			* count,
  int			* prod_sum,
  int			* prod_sumsq,
  int			* max_len,
  int			last_index)
{
  *count      = 0;
  *prod_sum   = 0;
  *prod_sumsq = 0;
  *max_len    = 0;

  for (int i = 1; i <= last_index; i++)
  {
    if (hist[i])
    {
      *prod_sum   += i * hist[i];
      *prod_sumsq += i * i * hist[i];
      *count      += hist[i];

      if (i > *max_len)
        *max_len = i;
    }
  }
}


int TransTable::CalcPercentile(
  int			hist[],
  double		threshold,
  int			last_index)
{
  int cum = 0;

  for (int i = 1; i <= last_index; i++)
  {
    cum += hist[i];
    if (cum >= threshold)
     return i;
  }
  return -1;
}


void TransTable::PrintHist(
  int			hist[],
  int			num_wraps,
  int			last_index)
{
  int count, prod_sum, prod_sumsq, max_len;

  TransTable::MakeHistStats(hist,
    &count, &prod_sum, &prod_sumsq, &max_len, last_index);

  for (int i = 1; i <= last_index; i++)
    if (hist[i])
      fprintf(fp, "%7d\t%5d\n", i, hist[i]);

  fprintf(fp, "\n");
  fprintf(fp, "Entries\t%5d\n", count);
  if (count)
  {
    fprintf(fp, "Full\t%5d\n", num_wraps);
    
    double mean = prod_sum / (double) count;
    fprintf(fp, "Average\t%5.2f\n", mean);

    double var = prod_sumsq / (double) count - mean * mean;
    if (var >= 0.)
      fprintf(fp, "Std.dev\t%5.2f\n", sqrt(var));

    fprintf(fp, "Maximum\t%5d\n", max_len);
  }
  fprintf(fp, "\n");
}


void TransTable::UpdateSuitHist(
  int			trick,
  int			hand,
  int			hist[],
  int			* num_wraps)
{
  distHashType * dp;

  * num_wraps = 0;
  for (int i = 0; i <= DISTS_PER_ENTRY; i++)
    hist[i] = 0;

  for (int hashkey = 0; hashkey < 256; hashkey++)
  {
    dp = &TTroot[trick][hand][hashkey];
    hist    [ dp->nextNo ]++;
    suitHist[ dp->nextNo ]++;

    if (dp->nextNo != dp->nextWriteNo)
    {
      (*num_wraps)++; // Not entirely correct
      suitWraps++;
    }
  }
}


void TransTable::PrintSuitStats(
  int			trick,
  int			hand)
{
  int			hist[DISTS_PER_ENTRY+1];
  int			num_wraps;

  TransTable::UpdateSuitHist(trick, hand, hist, &num_wraps);

  fprintf(fp, "Suit histogram for trick %d, hand %s\n", 
    trick, players[hand]);
  TransTable::PrintHist(hist, num_wraps, DISTS_PER_ENTRY);
}


void TransTable::PrintAllSuitStats()
{
  suitWraps   = 0;
  for (int i = 0; i <= DISTS_PER_ENTRY; i++)
    suitHist[i] = 0;

  for (int trick = 11; trick >= 1; trick--)
  {
    for (int hand = 0; hand < DDS_HANDS; hand++)
    {
      fprintf(fp, "Suit, Trick %d, hand %s\n", trick, players[hand]);
      fprintf(fp, "==========================\n\n");
      TransTable::PrintSuitStats(trick, hand);
    }
  }

  fprintf(fp, "Overall suit histogram\n");
  TransTable::PrintHist(suitHist, suitWraps, DISTS_PER_ENTRY);
}


void TransTable::PrintSummarySuitStats()
{
  int			hist[DISTS_PER_ENTRY+1];
  int			count, prod_sum, prod_sumsq, 
          		max_len, num_wraps;

  suitWraps = 0;
  for (int i = 0; i <= DISTS_PER_ENTRY; i++)
    suitHist[i] = 0;

  fprintf(fp, "Suit depth statistics\n\n");

  fprintf(fp, "%5s  %6s  %7s  %7s  %7s  %7s  %7s    P%-4.2f\n",
    "Trick",
    "Player",
    "Entries",
    "Full",
    "Average",
    "Std.dev",
    "Maximum",
    TT_PERCENTILE);

  for (int trick = 11; trick >= 1; trick--)
  {
    for (int hand = 0; hand < DDS_HANDS; hand++)
    {
      TransTable::UpdateSuitHist(trick, hand, hist, &num_wraps);
      TransTable::MakeHistStats(hist,
        &count, &prod_sum, &prod_sumsq, &max_len, DISTS_PER_ENTRY);

      double mean, var;
      if (count > 0)
      {
        mean = prod_sum / (double) count;
        var  = prod_sumsq / (double) count - mean * mean;
        if (var < 0.)
          var = 0.;
      }

      int percentile = 
	TransTable::CalcPercentile(hist, 
	  TT_PERCENTILE * count, DISTS_PER_ENTRY);

      if (count > 0)
        fprintf(fp, "%5d  %-6s  %7d  %7d  %7.2f  %7.2f  %7d  %7d\n",
          trick,
	  players[hand],
	  count,
	  num_wraps,
	  mean,
	  sqrt(var),
	  max_len,
	  percentile);
      else
        fprintf(fp, "%5d  %-6s  %7d  %7d  %7s  %7s  %7d  %7d\n",
          trick,
	  players[hand],
	  count,
	  num_wraps,
	  "-",
	  "-",
	  max_len,
	  percentile);
    }
    fprintf(fp, "\n");
  }
  fprintf(fp, "\n");
}


winBlockType * TransTable::FindMatchingDist(
  int			trick,
  int			hand,
  int			handDistSought[DDS_HANDS])
{
  winBlockType 		* bp;
  distHashType		* dp;
  int 			handDist[DDS_HANDS];

  for (int hashkey = 0; hashkey < 256; hashkey++)
  {
    dp = &TTroot[trick][hand][hashkey];
    for (int i = 0; i < dp->nextNo; i++)
    {
      bp = dp->list[i].posBlock;
      TransTable::KeyToDist(dp->list[i].key, trick, handDist);

      bool same = true;
      for (int h = 0; h < DDS_HANDS; h++)
      {
        if (handDist[h] != handDistSought[h])
	{
	  same = false;
	  break;
	}
      }
      if (same)
        return bp;
    }
  }
  return NULL;
}


void TransTable::PrintEntriesBlock(
  winBlockType		* bp,
  unsigned char		lengths[DDS_HANDS][DDS_SUITS])
{
  char			line[40];
  char			lines[2][80];

  TransTable::LenToStr(lengths, line);

  sprintf(lines[0], 
    "%d matches for   %s\n", bp->nextMatchNo, line);
  memset(lines[1], '=', 71);
  lines[1][71] = '\0';

  fprintf(fp, "%s%s\n\n", lines[0], lines[1]);

  for (int j = 0; j < bp->nextMatchNo; j++)
  {
    fprintf(fp, "Entry number %3d\n", j+1);
    fprintf(fp, "----------------\n\n");
    TransTable::PrintMatch(&bp->list[j], lengths);
  }
}



void TransTable::PrintEntriesDistAndCards(
  int			trick,
  int			hand,
  unsigned short   	* aggrTarget,
  int			handDist[DDS_HANDS])
{
  char			line[40];
  unsigned char		len[DDS_HANDS][DDS_SUITS];

  winBlockType * bp =
    TransTable::FindMatchingDist(trick, hand, handDist);

  TransTable::DistToLengths(trick, handDist, len);

  fprintf(fp, "Looking up entry for trick %d, hand %d\n",
    trick, hand);
  TransTable::LenToStr(len, line);
  fprintf(fp, "%s\n\n", line);

  if (! bp)
  {
    fprintf(fp, "Entry not found\n\n");
    return;
  }

  int * ab0 = aggr[ aggrTarget[0] ].aggrBytes[0];
  int * ab1 = aggr[ aggrTarget[1] ].aggrBytes[1];
  int * ab2 = aggr[ aggrTarget[2] ].aggrBytes[2];
  int * ab3 = aggr[ aggrTarget[3] ].aggrBytes[3];

  winMatchType TTentry;
  TTentry.topSet1 = ab0[0] | ab1[0] | ab2[0] | ab3[0];
  TTentry.topSet2 = ab0[1] | ab1[1] | ab2[1] | ab3[1];
  TTentry.topSet3 = ab0[2] | ab1[2] | ab2[2] | ab3[2];
  TTentry.topSet4 = ab0[3] | ab1[3] | ab2[3] | ab3[3];

  int matchNo = 1;
  int n = bp->nextMatchNo - 1;
  winMatchType * wp = &bp->list[n];

  for (int i = n; i >= 0; i--, wp--)
  {
    if ((wp->topSet1 ^ TTentry.topSet1) & wp->topMask1) 
      continue;

    if (wp->lastMaskNo != 1)
    {
      if ((wp->topSet2 ^ TTentry.topSet2) & wp->topMask2) 
        continue;

      if (wp->lastMaskNo != 2)
      {
        if ((wp->topSet3 ^ TTentry.topSet3) & wp->topMask3) 
          continue;
      }
    }

    fprintf(fp, "Match number %d\n", matchNo++);
    fprintf(fp, "---------------\n");
    TransTable::PrintMatch(&bp->list[i], len);
  }

  if (matchNo == 1)
    fprintf(fp, "%d matches for suit, none for cards\n\n", n);
  else
    fprintf(fp, "\n");
}


void TransTable::PrintEntriesDist(
  int			trick,
  int			hand,
  int			handDist[DDS_HANDS])
{
  unsigned char		len[DDS_HANDS][DDS_SUITS];

  winBlockType * bp =
    TransTable::FindMatchingDist(trick, hand, handDist);

  TransTable::DistToLengths(trick, handDist, len);

  if (! bp)
  {
    fprintf(fp, "Entry not found:  Trick %d, hand %d\n",
      trick, hand);
    char line[80];
    TransTable::LenToStr(len, line);
    fprintf(fp, "%s\n\n", line);
    return;
  }

  TransTable::PrintEntriesBlock(bp, len);
}


void TransTable::PrintEntries(
  int			trick,
  int			hand)
{
  winBlockType 		* bp;
  distHashType		* dp;
  int 			handDist[DDS_HANDS];
  unsigned char		lengths[DDS_HANDS][DDS_SUITS];

  for (int hashkey = 0; hashkey < 256; hashkey++)
  {
    dp = &TTroot[trick][hand][hashkey];
    for (int i = 0; i < dp->nextNo; i++)
    {
      bp = dp->list[i].posBlock;
      TransTable::KeyToDist(dp->list[i].key, trick, handDist);
      TransTable::DistToLengths(trick, handDist, lengths);

      TransTable::PrintEntriesBlock(bp, lengths);
    }
  }
}


void TransTable::PrintAllEntries()
{
  for (int trick = 11; trick >= 1; trick--)
  {
    for (int hand = 0; hand < DDS_HANDS; hand++)
    {
      fprintf(fp, "Entries, trick %d, hand %s\n", trick, players[hand]);
      fprintf(fp, "==============================\n\n");
      TransTable::PrintEntries(trick, hand);
    }
  }
  fprintf(fp, "\n");
}


void TransTable::UpdateEntryHist(
  int			trick,
  int			hand,
  int			hist[],
  int			* num_wraps)
{
  distHashType * dp;

  * num_wraps = 0;
  for (int i = 0; i <= BLOCKS_PER_ENTRY; i++)
    hist[i] = 0;

  for (int hashkey = 0; hashkey < 256; hashkey++)
  {
    dp = &TTroot[trick][hand][hashkey];
    for (int i = 0; i < dp->nextNo; i++)
    {
      int c = dp->list[i].posBlock->nextMatchNo;
      hist    [c]++;
      suitHist[c]++;

      if (c != dp->list[i].posBlock->nextWriteNo)
      {
        (*num_wraps)++; // Not entirely correct
        suitWraps++;
      }
    }
  }
}


void TransTable::PrintEntryStats(
  int			trick,
  int			hand)
{
  int			hist[BLOCKS_PER_ENTRY+1];
  int			num_wraps;

  TransTable::UpdateEntryHist(trick, hand, hist, &num_wraps);

  fprintf(fp, "Entry histogram for trick %d, hand %s\n", 
    trick, players[hand]);
  TransTable::PrintHist(hist, num_wraps, BLOCKS_PER_ENTRY);
}


void TransTable::PrintAllEntryStats()
{
  suitWraps   = 0;
  for (int i = 0; i <= BLOCKS_PER_ENTRY; i++)
    suitHist[i] = 0;

  for (int trick = 11; trick >= 1; trick--)
  {
    for (int hand = 0; hand < DDS_HANDS; hand++)
    {
      fprintf(fp, "Entry, trick %d, hand %s\n", trick, players[hand]);
      fprintf(fp, "============================\n\n");
      TransTable::PrintEntryStats(trick, hand);
    }
  }

  fprintf(fp, "Overall entry histogram\n");
  TransTable::PrintHist(suitHist, suitWraps, BLOCKS_PER_ENTRY);
}


int TransTable::EffectOfBlockBound(
  int			hist[],
  int 			size)
{
  // Calculates the number of blocks used if the blocks
  // are divided up in units of size, rather than in units
  // of BLOCKS_PER_ENTRY.  Only makes sense if size is less
  // than BLOCKS_PER_ENTRY, as we won't have statistics for
  // how many blocks above BLOCKS_PER_ENTRY would be created
  // if BLOCKS_PER_ENTRY were larger.

  int cum_memory   = 0;
  int unit_size    = 0;

  for (int i = 1; i <= BLOCKS_PER_ENTRY; i++)
  {
    if ((i-1) % size == 0)
      unit_size += size;

    cum_memory += hist[i] * unit_size;
  }
  return cum_memory;
}


// #define TT_MEMORY_SCENARIO

void TransTable::PrintSummaryEntryStats()
{
  int			hist[BLOCKS_PER_ENTRY+1];
  int			count, prod_sum, prod_sumsq,
  			max_len, num_wraps;

  int			cumCount  = 0;
  double		cumProd   = 0.;
#ifdef TT_MEMORY_SCENARIO
  int			cumMemory = 0;
#endif

  suitWraps = 0;
  for (int i = 0; i <= BLOCKS_PER_ENTRY; i++)
    suitHist[i] = 0;

  fprintf(fp, "Entry depth statistics\n\n");

  fprintf(fp, "%5s  %6s  %7s  %7s  %7s  %7s  %7s    P%-4.2f\n",
    "Trick",
    "Player",
    "Entries",
    "Full",
    "Average",
    "Std.dev",
    "Maximum",
    TT_PERCENTILE);

  for (int trick = 11; trick >= 1; trick--)
  {
    for (int hand = 0; hand < DDS_HANDS; hand++)
    {
      TransTable::UpdateEntryHist(trick, hand, hist, &num_wraps);
      TransTable::MakeHistStats(hist,
        &count, &prod_sum, &prod_sumsq, &max_len, BLOCKS_PER_ENTRY);

      cumCount  += count;
      cumProd   += prod_sum;
#ifdef TT_MEMORY_SCENARIO
      cumMemory += TransTable::EffectOfBlockBound(hist, 20);
#endif

      double mean = prod_sum / (double) count;
      double var  = prod_sumsq / (double) count - mean * mean;
      if (var < 0.)
        var = 0.;

      int percentile = 
	TransTable::CalcPercentile(hist, 
	  TT_PERCENTILE * count, BLOCKS_PER_ENTRY);

      fprintf(fp, "%5d  %-6s  %7d  %7d  %7.2f  %7.2f  %7d  %7d\n",
        trick,
	players[hand],
	count,
	num_wraps,
	mean,
	sqrt(var),
	max_len,
	percentile);
    }
    fprintf(fp, "\n");
  }
  fprintf(fp, "\n");

  fprintf(fp, "Blocks counted\t%8d\n", cumCount);

  fprintf(fp, "Blocks produced\t%8d\n", TransTable::BlocksInUse());

#ifdef TT_MEMORY_SCENARIO
  fprintf(fp, "Mem scenario\t%7.2f%%\n", 
    100. * cumMemory / ((double) BLOCKS_PER_ENTRY * cumCount));
#endif
  
  if (cumCount)
    fprintf(fp, "Fullness\t%7.2f%%\n",
      100. * cumProd / (BLOCKS_PER_ENTRY * cumCount));
  fprintf(fp, "\n");
}


void TransTable::PrintPageSummary()
{
  if (pageStats.numResets == 0)
    return;

  fprintf(fp, "Page statistics\n\n");

  fprintf(fp, "%-10s  %6s  %6s\n", 
    "Type", "Number", "Avg");

  fprintf(fp, "%-10s  %6d\n",
    "Resets", 
    pageStats.numResets);
  fprintf(fp, "%-10s  %6d  %6.2f\n",
    "calloc", 
    pageStats.numCallocs,
    pageStats.numCallocs / (double) pageStats.numResets);
  fprintf(fp, "%-10s  %6d  %6.2f\n",
    "free", 
    pageStats.numFrees,
    pageStats.numFrees / (double) pageStats.numResets);
  fprintf(fp, "%-10s  %6d  %6.2f\n\n",
    "harvest", 
    pageStats.numHarvests,
    pageStats.numHarvests / (double) pageStats.numResets);
}
